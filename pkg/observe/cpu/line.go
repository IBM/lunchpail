package cpu

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/lipgloss"
	"github.com/dustin/go-humanize"

	"lunchpail.io/pkg/be/events/utilization"
	comp "lunchpail.io/pkg/lunchpail"
	"lunchpail.io/pkg/observe/colors"
)

type resource string

const (
	cpu resource = "CPU"
	mem          = "Memory"
)

// Format `message` generated by some component `who`
func format(who, message string, prefixStyle lipgloss.Style, msgStyle lipgloss.Style) string {
	return fmt.Sprintf("%s%s", prefixStyle.Render(fmt.Sprintf("%8s", who)), msgStyle.Render(message))
}

func cpuline(workers []utilization.Worker, resource resource) string {
	line := []string{}

	prevPrefix := ""
	for _, worker := range workers {
		prefix := ""
		switch worker.Component {
		case comp.DispatcherComponent:
			prefix = "D "
		case comp.WorkersComponent:
			prefix = "W "
		case comp.WorkStealerComponent:
			prefix = "S "
		case comp.MinioComponent:
			prefix = "M "
		}

		if prefix == prevPrefix {
			prefix = ""
		} else {
			prevPrefix = prefix
		}

		// compute the length of both cpu and mem, so we can align them across rows
		cpuVal := fmt.Sprintf("%s%s%%", prefix, humanize.FtoaWithDigits(worker.CpuUtil, 1))
		memVal := fmt.Sprintf("%s%s", prefix, humanize.Bytes(worker.MemoryBytes))
		maxlen := max(len(cpuVal), len(memVal))

		var val string
		switch resource {
		case cpu:
			val = fmt.Sprintf("%-*s", maxlen, cpuVal)
		case mem:
			val = fmt.Sprintf("%-*s", maxlen, memVal)
		}

		if val != "" {
			info := colors.ComponentStyle(worker.Component).Render(val)
			line = append(line, info)
		}
	}

	return format(string(resource), strings.Join(line, ""), colors.OtherComponentStyle, colors.Dim)
}
